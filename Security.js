/** Security in React Native - General Mobile security.
     * We put effort to build more secure app.
     * Penetration was not impossible but we can reduce the probability.

        * Storing Sensitive Info.
        * Authentication and Deep-linking.
        * Network Security.
*/

/** Storing sensitive data
    - Config: react-native-dotenv, react-native-config are great for environment specific variables.
    - API-Keys: Serverless fucntions :(using AWS lambda/google cloud functions) as an oscastrations layer, which can forward requests with required API key or secret.
    - Persistant data: saving and reusing the data on the device(like session keys to cut down the network requests b/w the sessions)
    - AsyncStorage: Persisting non-sensitive data, persisting redux state, persisting graph-DL state, storaing global app-wide variables.
    - Secure Storage: React native does not provide any default way of storing sensitive data. However there are preexisting solutions separatly for iOS and Android.
        * iOS - Keychain Services: allows to you store small chunks of sensitive data.
        * Android - Secured Shared Prerences: not encrypted by default. but there Encrypted Shared Preferences wrapper class is available.
        * Android KeyStore: Storing cryptoGrapgic keys

        Unified API libraries in Raact-native for above secure storages:
        * expo-secure-store
        * react-native-ecrypted-storage
        * react-native-keychain. (iOS) / redux-persist-sensitive-storage (iOS % Android)
 */

/** Authentications and Deep Linking
      Deepinking: A waya of sending data directly.
      looks like: app://
      Deep links are not secure, you should never be sending any secure data in them.

      iOS: using universal links allow linking to content securly within your app.

        OAuth2: 
            Popular authentications protocol nowadays.
            Most complete secure protocol around.
            User asked to authenticate via third-party
            On successful completion, third-party redireccts back to requesting app with verification code.
            Which can be exchanged for JWT(JSON Web Token-Open standard for securely transmitting info b/w parties on the Web).
        
        Redirects:
            On web redirect step is secure bcuz the URLs are unique.
            Not secure for apps, as mentioned above. Hence, PKCE
                PKCE, "Pixy" Proof of Key Code Exchange
                    It is an extension to OAuth2 spec.
                    It uses additional layer of security which verifies authentication and token exchange requests coming from same client.
                    It uses SHA256 Cryptographic Hash Algorithm.
                        It create unique signature for text file of any size but it is:
                        Always the same length regardless of the input file.
                        Guranteed to produce same result with same input.
                        One way(you can't reverse engineer it to reveal the original output).
                Now you have 2 values:
                    * code_verifier: a large random string generated by the client
                    * code_challenge: the SHA256 of the code_verifier.
                During the initial /authorize request the client sends code_challenge for the code_verifier it keeps in memory.
                After the auth request has returned correctly, the client also sends the code_verifier that was used in the code_challenge.
                The IDP will then caluculate the code_challenge, see if it matches wht was sent on the very first /authorize request.
                And only sends the access token if the values matches.
                
                Image:
                2022-11-26-17-31-10.png
 */

/** Network Security
        APIs should always use SSL encryption.
        SSL encryption protects against the requested data being read in plain text b/w when it leaves the server and reaches the client.
        it starts with https://
        
        SSL Pinning: 
            Why SSL pinning:
                Using https endpoints could still leave your data vulnarable to interception.
                With https, the client only engage with secure https server with valid certificates which are signed by valid sCertiificate Authority.
                An attacker could take advantage of this by installing a malicious root CA certificate to the client user's device.
                This will leave you vulnarable to man-in-the-middle attack.
            SSL pinning: 
                This technique can be used on the client side.
                It works by embedding (Pinning) a list of trusted certificates during the development.
                So that only the requests signed with one of the trusted certificates will be accepted, and any self-signed certs will not be.
 */